#### 1. 描述一个DBMS的组件？
回答：以postgres为例子，
psql->查询解析->查询优化->执行引擎->索引or记录->缓存->存储
    |-> 事务管理          |->并发控制 (MVCC, 锁)
                         |->日志恢复

#### 2. 执行一条SQL，数据库系统做了那些事？
回答：
词法分析 -> 语法分析 -> 语义分析 -> 优化器处理 -> 执行计划生成 -> 引擎处理 -> 数据返回
                        （语法树）                      （执行计划）

#### 3. OLAP和OLTP，行存和列存，NSM，DSM和PAX
回答：
|   |   |   |   |
| ---- | ---- | ---- | ---- |
| TP  | 行存 | 事务型 | NSM |
| AP  | 列存 | 分析型 | DSM |

**NSM**
逐行插入页面  
|----------------------------------------|  
| Page Header | RH1 | 0962 |Jane | 30 |  
| RH2 | 7389 | John | 45 |..........................|  
|----------------------------------------|  
**DSM**
逐列插入页面  
|-------------------------------------------------|   
| Page Header | RH1 | 0962 | RH2 | 7389 | ........|  
|-------------------------------------------------|      
| Page Header | RH1 | Jane | RH2 | John | .........|  
|-------------------------------------------------|  

**PAX**   
|-----------------------------------------|  
| Page Header | 0962 | 7389 | ..................|  
|  
| Jane | John | ................................................|   
|  
| 30 | 52 | .........................................................|   
|-----------------------------------------|


#### 4. Redo和Undo的作用，checkpoint的作用
回答：  
- redo log：重做日志，每当有操作时，在数据变更之前将操作写入 redo log，这样当发生掉电之类的情况时系统可以在重启后继续操作。（持久性）

- undo log：撤销日志，当一些变更执行到一半无法完成时，可以根据撤销日志恢复到变更之间的状态。（原子性）

PG和mysql，见问题5

Check point：检查点，事务的记录点，redo时通过checkpoint进行日志回放。

#### 5. 数据库buffer相关算法和日志的关系

PG和GP使用steal-no-force，但是又redo log，无 undo log，用MVCC判断可见性。

- steal: 磁盘上可能包含uncommitted的数据，因此需要undo log，回滚时使用。
- no-steal：不存uncommitted数据，无需undo log.
- force：事务commit之后立刻持久化到硬盘
- no-force：不需要立刻，可以先缓存再批量持久化，因此需要redo log，断电重启后可以进行rollback。


#### 6. 索引
- 哈希索引：适合点查询  
- B树索引：适合范围查询
- 跳表索引
- 位图索引

聚集索引的叶子节点就是最终的数据节点
非聚集索引的叶子节点依然是索引节点

There are totally 7 indexes in GPDB 7X;  
gpadmin=# SELECT * FROM pg_am where amtype='i';  
 oid  | amname |  amhandler  | amtype  
------+--------+-------------+--------  
  403 | btree  | bthandler   | i  
  405 | hash   | hashhandler | i  
  783 | gist   | gisthandler | i  
 2742 | gin    | ginhandler  | i  
 4000 | spgist | spghandler  | i  
 3580 | brin   | brinhandler | i  
 7013 | bitmap | bmhandler   | i  
 (7 rows)  


#### 7. 查询优化简介
- Rule-based：完全根据语法
- Cost-based：基于分析数据和索引列的分布统计

主要包括 查询分析，索引选择，连接选择。

#### 8. Countmin，Hyperloglog和布隆过滤器的作雍
- Countmin和Heyperloglog都是基数估计（Cardinality Estimation）算法，估计一个集合不重复元素的个数
- BloomFilter：用于检测一个元素是否在一个集合中

#### 9. Join的方法和适用情况
- HashJoin：两表行数差别巨大，小表作成Hash表
- Nested loop join：内表较小或者索引选择性较好的情况
- Sort merge joind：没有索引已经排好序的数据

#### 10. HashJoin的算法思想
通过连接字段的值映射到哈希表中的桶。然后两表进行哈希连接
- 小表（左，内）哈希计算，置于桶中
- 大表（右，外）逐行扫描得到哈希值
- 匹配哈希值，找桶
- 合并匹配行

适用于大规模等值连接

#### 11. 外排序 sort-merge
External sorting
指能够处理极大两数据的排序算法，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存上。  
策略：排序+归并

#### 12. ACID及其技术事项

PG通过MVCC和WAL实现ACID。  
A：原子性 atomicity <- MVCC  
C: 一致性 consistency <- WAL  
I: 隔离行 isolation <- MVCC  
D：持久性 duration <-MVCC  

A: 事务的原子性，全部执行或者全部不执行  
C：不破坏数据完整，每个事务让数据库从一个一致性状态到另一个一致性状态  
I：允许多个事务并行  
D：修改是永久的  

#### 13. 隔离级别

| 级别 | 脏读 | 不可重复读 | 幻读 |
| :-----| :----: | :----: | :----: |
| 未提交读 RU |  |  |  |
| 已提交读 RC | × |  |  |
| 可重复读 RR | × | × |  |
| 串行读 SSI | × | × | × |


- RU：PG不支持
- RC：在一个事务commit后，另一个事务可以读到这个事务的改动
- RR：当前事务每次执行一条语句的结果始终一致，不收到其它事务的影响，看不见其它事务对数据的改动。


PG9.1是一个实现工业街别SSI的数据库。

#### 14. 常见的并发控制算法
- 两阶段加锁 2PL
- MVCC
- 乐观并发控制

#### 15.MVCC思想
多版本并发控制 multi version concurrency control
为每一个读写操作操作创建多个版本的数据，来解决并发冲突。
PG使用Snapshot Isolation（快照隔离）来实现MVCC。
每个SQL语句都只关注当前事务开始时候的快照。


#### 16. 锁和粒度、死锁检测
- 表级锁一共有8种
- 行级锁：同一个事务可能会在相同行上保持冲突的锁
- 页面级：

死锁检测和性能trade-off
deadlock-timeout默认设置1s，自动随机回滚其中一个。

#### 17. 什么是谓词下推

将尽可能多的判断更贴近数据源，以使查询时能跳过无关的数据。




